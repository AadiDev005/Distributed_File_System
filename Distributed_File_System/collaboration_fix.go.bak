package main

import (
	"bytes"
	"encoding/json"
	"log"
	"net/http"

	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// WebSocket upgrader with security
var collaborationUpgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		origin := r.Header.Get("Origin")
		allowedOrigins := []string{
			"http://localhost:3001",
			"http://localhost:3000",
		}
		for _, allowed := range allowedOrigins {
			if origin == allowed {
				return true
			}
		}
		return false
	},
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}

// Initialize collaboration for EnterpriseFileServer
func (efs *EnterpriseFileServer) InitializeCollaboration() {
	if efs.collaborationDocs == nil {
		efs.collaborationDocs = make(map[string]*CollaborativeDocument)
	}
	if efs.collaborationClients == nil {
		efs.collaborationClients = make(map[string]*CollabClient)
	}

	// Setup endpoints
	http.HandleFunc("/ws/collaboration", efs.handleCollaborationWebSocket)
	http.HandleFunc("/api/collaboration/health", efs.handleCollaborationHealth)

	log.Println("ü§ù Enterprise Collaboration initialized")
}

// Handle WebSocket connections
func (efs *EnterpriseFileServer) handleCollaborationWebSocket(w http.ResponseWriter, r *http.Request) {
	// Authenticate using existing session system
	sessionID := r.Header.Get("X-Session-ID")
	if sessionID == "" {
		sessionID = r.URL.Query().Get("session")
	}

	// For now, create a basic user (replace with actual auth validation)
	user := &User{
		ID:       "user-" + sessionID,
		Username: "Enterprise User",
	}

	conn, err := collaborationUpgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("WebSocket upgrade error: %v", err)
		return
	}
	defer conn.Close()

	// Create authenticated client
	client := &CollabClient{
		ID:        user.ID,
		Name:      user.Username,
		Email:     user.Email,
		Conn:      conn,
		SessionID: sessionID,
		IsOnline:  true,
		LastSeen:  time.Now(),
		send:      make(chan []byte, 256),
	}

	efs.collaborationMutex.Lock()
	efs.collaborationClients[client.ID] = client
	efs.collaborationMutex.Unlock()

	log.Printf("üîå Enterprise user connected: %s (%s)", client.Name, client.Email)

	// Start WebSocket pumps
	go efs.clientWritePump(client)
	go efs.clientReadPump(client)
}

// Get or create document
func (efs *EnterpriseFileServer) getOrCreateDocument(docID string) *CollaborativeDocument {
	efs.collaborationMutex.Lock()
	defer efs.collaborationMutex.Unlock()

	if doc, exists := efs.collaborationDocs[docID]; exists {
		return doc
	}

	doc := &CollaborativeDocument{
		ID:            docID,
		Title:         docID,
		Content:       efs.getDefaultDocumentContent(docID),
		Version:       1,
		LastModified:  time.Now(),
		Collaborators: make(map[string]*CollabClient),
		Changes:       []DocumentChange{},
		Encrypted:     true,
	}

	efs.collaborationDocs[docID] = doc
	return doc
}

// Store document to P2P network with correct method signature
func (efs *EnterpriseFileServer) storeDocumentToP2P(doc *CollaborativeDocument) {
	key := "collab_" + doc.ID
	data := []byte(doc.Content)

	// Encrypt if enterprise encryption is available
	if efs.enterpriseEncryption != nil {
		encryptedFile, err := efs.enterpriseEncryption.EncryptForUser("system", data)
		if err == nil && encryptedFile != nil {
			data = encryptedFile.Data
		}
	}

	// Use correct writeStream signature (3 parameters)
	if _, err := efs.store.writeStream(key, "collaboration", bytes.NewReader(data)); err != nil {
		log.Printf("‚ùå Failed to store document to P2P: %v", err)
		return
	}

	doc.FileHash = key
	log.Printf("üíæ Document stored to P2P network: %s", doc.ID)
}

// WebSocket write pump
func (efs *EnterpriseFileServer) clientWritePump(client *CollabClient) {
	ticker := time.NewTicker(54 * time.Second)
	defer func() {
		ticker.Stop()
		client.Conn.Close()
	}()

	for {
		select {
		case message, ok := <-client.send:
			client.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if !ok {
				client.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			w, err := client.Conn.NextWriter(websocket.TextMessage)
			if err != nil {
				return
			}
			w.Write(message)

			if err := w.Close(); err != nil {
				return
			}

		case <-ticker.C:
			client.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if err := client.Conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}

// WebSocket read pump
func (efs *EnterpriseFileServer) clientReadPump(client *CollabClient) {
	defer func() {
		efs.cleanupClient(client)
		client.Conn.Close()
	}()

	client.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
	client.Conn.SetPongHandler(func(string) error {
		client.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
		return nil
	})

	for {
		_, messageBytes, err := client.Conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("WebSocket error for user %s: %v", client.Name, err)
			}
			break
		}

		var msg WSMessage
		if err := json.Unmarshal(messageBytes, &msg); err != nil {
			log.Printf("JSON unmarshal error for user %s: %v", client.Name, err)
			continue
		}

		efs.handleClientMessage(client, msg)
	}
}

// Handle WebSocket messages
func (efs *EnterpriseFileServer) handleClientMessage(client *CollabClient, msg WSMessage) {
	switch msg.Type {
	case "fetch-document":
		efs.handleFetchDocument(client, msg.Payload)
	case "join-document":
		efs.handleJoinDocument(client, msg.Payload)
	case "document-change":
		efs.handleDocumentChange(client, msg.Payload)
	default:
		log.Printf("Unknown message type from %s: %s", client.Name, msg.Type)
	}
}

// Handle fetch document
func (efs *EnterpriseFileServer) handleFetchDocument(client *CollabClient, payload interface{}) {
	data, _ := json.Marshal(payload)
	var fetchData struct {
		DocumentID string `json:"documentId"`
	}
	json.Unmarshal(data, &fetchData)

	doc := efs.getOrCreateDocument(fetchData.DocumentID)

	response := map[string]interface{}{
		"success": true,
		"document": map[string]interface{}{
			"id":           doc.ID,
			"title":        doc.Title,
			"content":      doc.Content,
			"version":      doc.Version,
			"lastModified": doc.LastModified,
			"encrypted":    doc.Encrypted,
		},
	}

	client.sendMessage("fetch-document-response", response)
}

// Handle joining a document
func (efs *EnterpriseFileServer) handleJoinDocument(client *CollabClient, payload interface{}) {
	data, _ := json.Marshal(payload)
	var joinData struct {
		DocumentID string `json:"documentId"`
		UserID     string `json:"userId"`
		UserName   string `json:"userName"`
	}
	json.Unmarshal(data, &joinData)

	client.DocumentID = joinData.DocumentID

	doc := efs.getOrCreateDocument(joinData.DocumentID)
	doc.mutex.Lock()
	doc.Collaborators[client.ID] = client
	doc.mutex.Unlock()

	log.Printf("üëã User %s joined document %s", client.Name, joinData.DocumentID)
}

// Handle document changes
func (efs *EnterpriseFileServer) handleDocumentChange(client *CollabClient, payload interface{}) {
	data, _ := json.Marshal(payload)
	var changeData struct {
		DocumentID string `json:"documentId"`
		Content    string `json:"content"`
		Change     struct {
			ID        string    `json:"id"`
			Type      string    `json:"type"`
			Position  int       `json:"position"`
			Content   string    `json:"content"`
			Timestamp time.Time `json:"timestamp"`
			Version   int       `json:"version"`
		} `json:"change"`
	}
	json.Unmarshal(data, &changeData)

	doc := efs.getOrCreateDocument(changeData.DocumentID)
	doc.mutex.Lock()
	doc.Content = changeData.Content
	doc.Version = changeData.Change.Version
	doc.LastModified = time.Now()
	doc.mutex.Unlock()

	// Store to P2P network
	go efs.storeDocumentToP2P(doc)

	log.Printf("üìù Document change by %s in %s", client.Name, changeData.DocumentID)
}

// Send message to client
func (client *CollabClient) sendMessage(msgType string, payload interface{}) {
	msg := WSMessage{
		Type:    msgType,
		Payload: payload,
	}

	msgBytes, _ := json.Marshal(msg)
	select {
	case client.send <- msgBytes:
	default:
		close(client.send)
	}
}

// Cleanup client connection
func (efs *EnterpriseFileServer) cleanupClient(client *CollabClient) {
	client.IsOnline = false
	client.LastSeen = time.Now()

	efs.collaborationMutex.Lock()
	delete(efs.collaborationClients, client.ID)
	efs.collaborationMutex.Unlock()

	log.Printf("üîö User disconnected: %s", client.Name)
}

// Health check for collaboration
func (efs *EnterpriseFileServer) handleCollaborationHealth(w http.ResponseWriter, r *http.Request) {
	efs.collaborationMutex.RLock()
	activeClients := len(efs.collaborationClients)
	activeDocuments := len(efs.collaborationDocs)
	efs.collaborationMutex.RUnlock()

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":           "healthy",
		"active_clients":   activeClients,
		"active_documents": activeDocuments,
		"timestamp":        time.Now().Format(time.RFC3339),
	})
}

// Default document content
func (efs *EnterpriseFileServer) getDefaultDocumentContent(docID string) string {
	content := map[string]interface{}{
		"type": "doc",
		"content": []map[string]interface{}{
			{
				"type":  "heading",
				"attrs": map[string]interface{}{"level": 1},
				"content": []map[string]interface{}{
					{"type": "text", "text": "üè¢ Enterprise Document: " + docID},
				},
			},
			{
				"type": "paragraph",
				"content": []map[string]interface{}{
					{"type": "text", "text": "Quantum-encrypted collaborative document ready for real-time editing."},
				},
			},
		},
	}

	contentBytes, _ := json.Marshal(content)
	return string(contentBytes)
}
